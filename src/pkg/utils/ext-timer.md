好的！下面把你要改的行為整理成一份「人人看得懂」的規格草案（不含程式碼），方便你和團隊逐條確認。

# ExtTimer（新規格草案）

## 1) 目標

* 在 **不預先建立大量 alarms** 的前提下，依需求**動態重現**同一組 bucket alarm 行為。
* 以一個**固定參考時間點**對齊所有 bucket 與任務節拍，讓 SW 重啟後也能得到**一致的時間軸**。
* 允許「**用較小的 bucket alarm** 驅動較長的 interval 任務」，靠執行時的**倍數檢查**決定是否真正執行。
* 保留延遲恢復時的**打散策略**（延遲≥65s → 單次 8–24s offset），但**不改變下一次排程節點**。

---

## 2) 關鍵設定（不變）

* `BUCKET_MINUTES = [5, 10, 30, 60, 180, 480, 1440]`（單位：分鐘）

---

## 3) 生命週期與狀態來源

* **參考時間點（Reference Time）**

  * 於**擴充啟動時**寫入 `chrome.storage.session`（例如 `referenceTimeMs`）。
  * **SW 重啟**後由 `storage.session` 讀回同一數值，確保在同一瀏覽器工作階段中**一致對齊**。
  * 備註：`storage.session` 在**整個瀏覽器重啟**後會重置；如需跨重啟延續，另行討論是否也同步一份到 `storage.local`（見 §10 開放議題）。

* **任務清單與快照**

  * 任務本身（id、due、period、payload…）仍建議**持久化於 `storage.local`**，以便 SW 回收/重載後可 rehydrate（此部分沿用舊版策略）。

---

## 4) 任務建立（Add Task）規則

1. **Interval 要求（硬限制）**

   * 新增 interval 任務時，`interval` 必須是 `BUCKET_MINUTES` 之中**至少一個值的整數倍**。
   * 若不滿足，直接拒絕（或回報錯誤），以保障後續用 bucket 驅動時的對齊判定。

2. **選擇基礎桶（Base Bucket）**

   * 從 `BUCKET_MINUTES` 中挑選能**整除該 interval** 的值作為**基礎桶**。
   * 原則：**取「可整除且不大於 interval」的最大值**，以降低「每次 tick 都跳過」的頻率。
   * 例：`interval = 5 小時`（300 分）→ 可被 `60 分` 整除，`60` 是候選中最大者，故選 **1 小時 bucket**。

3. **初次對齊與 Alarm 動態生成**

   * 基於**參考時間點**（`referenceTimeMs`）和**基礎桶**，計算該 bucket 的節拍序列：
     `referenceTime + n * baseBucketMinutes`。
   * **最初沒有 alarm** 時，才為該 bucket **建立對應 alarm**（可為週期性 alarm）。
   * 藉由這個規則，我們**不需要初始化就生成一堆 alarms**；而是在「首次需要時」**按同一參考點重現**相同的 alarm。

4. **計算任務的下一個目標時間點（Target Due）**

   * 以**同一參考時間點**為錨，根據任務的 `interval` 找出 `referenceTime + k * interval` 中**第一個 ≥ 現在**的時間點，作為該任務的**目標 due**。

5. **半個 Interval 的跳過規則（首拍優化）**

   * 若「**目標 due 與現在**」的時間差 `<= interval / 2`，則**跳過這一拍**（不執行，等待下一個 `+ interval` 的節點）。
   * 目的：避免在貼近邊界時做出「剛啟動就很快執行一次」的抖動。

---

## 5) Alarm 觸發時的執行判定

* 當**基礎桶 alarm** 觸發（例如每 1 小時）：

  1. 對**同桶下的所有任務**逐一檢查：

     * 以 `referenceTime + k * interval` 的**等差序列**為準，找出最近且不早於 now 的**目標 due**。
     * 若本次 alarm 時刻（或實際 now）**對齊到該目標 due**（在容差內），則此任務**允許執行**；否則**跳過**。
  2. 這代表：**短桶（例如 1 小時）可承載長 interval（例如 5 小時）**，透過「倍數檢查」只在**第 5 次**（或第 10、15…次）才真正執行。

---

## 6) 延遲與打散（Drift Control）

* 若實際執行與「目標 due」之間的**延遲 ≥ 65 秒**，視為非理想排程：

  * 對本次執行套用**單次 8～24 秒**的隨機 offset（打散），**僅影響本次**。
  * **下一個目標 due 不變**（仍沿用 `referenceTime + k * interval` 序列）。
  * **alarm 也不變**（bucket 固定不改）。

---

## 7) 併發與看門狗（延續既有邏輯）

* 可沿用既有 `maxConcurrency` / `handlerTimeoutMs` 的治理方式，確保**短時睡眠（offset）**和**跳過策略**不會造成執行擁塞。

---

## 8) SW 重啟的一致性

* **參考時間點**：從 `storage.session` 讀回 → **節拍不變**。
* **bucket alarm**：若尚未存在，於**首次需要**時再**按同一參考時間點**動態建立 → **行為一致**。
* **任務快照**：從 `storage.local` 讀回（若沿用舊版保存），可繼續知道有哪些任務、各自的 interval 與 payload 等。

---

## 9) 行為範例（易懂版）

* 參考時間點：`T0`（擴充啟動時寫入）
* `interval = 5 小時` → 基礎桶選 `1 小時`
* 第一次要跑的是 `T0 + 5h`、下一次 `T0 + 10h`、以此類推。
* 我們只建立「每 1 小時」的 bucket alarm。
* 每次 1 小時 alarm 來時，檢查**現在**是否剛好踩到 `T0 + k*5h`（在容差內）：

  * 若是 → 執行；
  * 若否 → 跳過。
* 若某次執行發現**晚到 ≥ 65 秒**，只對該次加 **8～24 秒 offset**；下一次仍是 `T0 + (k+1)*5h`，不受影響。

---

## 10) 開放議題（待你們團隊確認）

1. **瀏覽器重啟**

   * `storage.session` 會重置；是否要把 `referenceTime` **備份一份到 `storage.local`**，以便跨瀏覽器重啟後仍維持相同對齊？
   * 若不備份：重啟後新的 `referenceTime` 會變，所有節拍序列也會以新錨點計算（可能是可接受的）。

2. **容差窗口**

   * 「對齊判定」與「半個 interval 跳過」是否需要具體毫秒級容差（例如 ±10s）？
   * 與「打散 8～24s」之間的交互需否特別記錄（例如 telemetry）？

3. **多任務密集度**

   * 同一刻（同一個 `T0 + k*interval`）大量任務命中時，是否仍要保留**有界併發**與**單次 offset**以防尖峰？

4. **非整除的 interval**

   * 目前規範是**硬拒**。是否要提供「自動就近取可整除的基礎桶」或「提示可選的合法 interval」的友善引導？

5. **錯過多拍的補償**

   * 若系統長時間休眠導致錯過多個節點，恢復時是否**只執行一拍**還是**多拍補償**？（目前描述為「只執行命中的那拍」）

6. **觀測與診斷**

   * 是否要新增統計：每任務「被跳過次數、實際執行延遲分佈、打散幅度」等，方便後續調參？

---

## 11) 一句話總結

> **以固定參考時間點 + 動態建立 bucket alarm + 倍數檢查** 來驅動所有 interval；**延遲時僅對當次加 8–24 秒 offset，不改下一拍**。如此在 SW 重啟後也能**重現同一條時間軸**，同時避免初始化時建立一大堆 alarm。
